import requests
import sqlite3
import os
import time

# Set API keys
OMDB_API_KEY = '845af1f7'
TMDB_API_KEY = 'e4d04998880c3bf739e025355c5327b9'

# API URLs
OMDB_URL = 'https://www.omdbapi.com/'
TMDB_URL = "https://api.themoviedb.org/3"

# SQLite DB setup
DB_NAME = 'movies.db'
TABLE_NAME = 'omdb_movies'
TMDB_TABLE_NAME = 'tmdb_table'
JOINED_TABLE_NAME = 'joined_movies'
SHARED_TABLE_NAME = 'shared_movies'

# Create SQLite database and table (without Rotten Tomatoes rating)
def setup_database():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    
    # Create shared_movies table with an auto-incrementing id
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS {SHARED_TABLE_NAME} (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT UNIQUE
        )
    ''')

    # Create omdb_movies table
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
            imdb_id TEXT PRIMARY KEY,
            title TEXT,
            imdb_rating REAL,
            movie_id INTEGER,
            FOREIGN KEY (movie_id) REFERENCES {SHARED_TABLE_NAME}(id)
        )
    ''')

    # Create tmdb_table
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS {TMDB_TABLE_NAME} (
            tmdb_id INTEGER PRIMARY KEY,
            title TEXT,
            total_revenue INTEGER,
            movie_id INTEGER,
            FOREIGN KEY (movie_id) REFERENCES {SHARED_TABLE_NAME}(id)
        )
    ''')

    # Create joined_movies table
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS {JOINED_TABLE_NAME} (
            movie_id INTEGER PRIMARY KEY,
            imdb_rating REAL,
            total_revenue INTEGER,
            FOREIGN KEY (movie_id) REFERENCES {SHARED_TABLE_NAME}(id)
        )
    ''')

    conn.commit()
    conn.close()

# Get a page of popular movie titles from TMDb
def fetch_titles_from_tmdb(page=1):
    url = f"{TMDB_URL}/movie/popular"
    params = {
        "api_key": TMDB_API_KEY,
        "language": "en-US",
        "page": page
    }

    response = requests.get(url, params=params)
    if response.status_code != 200:
        print(f"[TMDB ERROR {response.status_code}]: {response.text}")
        return []

    try:
        data = response.json()
        return [movie['title'] for movie in data.get('results', [])]
    except Exception as e:
        print(f"[JSON DECODE ERROR]: {e}")
        print("Response text:", response.text)
        return []

# Query OMDb for details on one movie
def fetch_movie_data_from_omdb(title):
    params = {
        't': title,
        'apikey': OMDB_API_KEY
    }

    response = requests.get(OMDB_URL, params=params)
    if response.status_code != 200:
        print(f"[OMDB ERROR {response.status_code}]: {response.text}")
        return None

    try:
        data = response.json()
        if data.get("Response") == "False":
            return None

        imdb_id = data.get("imdbID")
        imdb_rating = float(data.get("imdbRating", 0)) if data.get("imdbRating") not in ['N/A', None] else None

        return {
            "title": data.get("Title"),
            "imdb_id": imdb_id,
            "imdb_rating": imdb_rating
        }
    except Exception as e:
        print(f"[OMDB JSON ERROR]: {e}")
        return None

# Store movie title in shared_movies and return the id
def store_shared_movie(title):
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute(f"INSERT OR IGNORE INTO {SHARED_TABLE_NAME} (title) VALUES (?)", (title,))
    conn.commit()
    cursor.execute(f"SELECT id FROM {SHARED_TABLE_NAME} WHERE title = ?", (title,))
    movie_id = cursor.fetchone()[0]
    conn.close()
    return movie_id

# Store movie data in the database
def store_movie_in_db(movie_data):
    if not movie_data or not movie_data.get("imdb_id"):
        return False  # Skip invalid data

    movie_id = store_shared_movie(movie_data["title"])

    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()

    # Insert into omdb_movies table
    cursor.execute(f'''
        INSERT OR IGNORE INTO {TABLE_NAME} (imdb_id, title, imdb_rating, movie_id)
        VALUES (?, ?, ?, ?)
    ''', (
        movie_data["imdb_id"],
        movie_data["title"],
        movie_data["imdb_rating"],
        movie_id
    ))

    conn.commit()
    rows_affected = cursor.rowcount
    conn.close()

    return rows_affected > 0  # Return True if inserted

# Fetch and store up to 25 NEW movies per execution
def fetch_and_store_movies():
    setup_database()

    inserted_count = 0
    page = 1

    print(f"[INFO] Starting data insertion (max 25 new items)...")

    while inserted_count < 25:
        titles = fetch_titles_from_tmdb(page)
        if not titles:
            break

        for title in titles:
            if inserted_count >= 25:
                break
            movie_data = fetch_movie_data_from_omdb(title)
            if movie_data:
                was_inserted = store_movie_in_db(movie_data)
                if was_inserted:
                    inserted_count += 1
                    print(f"[+]{inserted_count}: Stored '{movie_data['title']}'")
                else:
                    print(f"[=] Skipped duplicate: '{movie_data['title']}'")

            time.sleep(0.5)  # Respect API rate limits

        page += 1

    print(f"[DONE] Inserted {inserted_count} new movie(s) into the database.")

def join_movies():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()

    # Join the data from OMDb and TMDb into joined_movies using the movie_id
    cursor.execute(f'''
        INSERT INTO {JOINED_TABLE_NAME} (movie_id, imdb_rating, total_revenue)
        SELECT omdb.movie_id, omdb.imdb_rating, tmdb.total_revenue
        FROM {TABLE_NAME} AS omdb
        JOIN {TMDB_TABLE_NAME} AS tmdb ON omdb.title = tmdb.title
    ''')

    conn.commit()
    conn.close()
    print("[INFO] joined_movies table updated with movie data using movie_ids.")

# Main function
def main():
    fetch_and_store_movies()  # Fetch and store movies from OMDb and TMDb
    join_movies()  # Join data from both APIs into the final table

if __name__ == "__main__":
    main()
