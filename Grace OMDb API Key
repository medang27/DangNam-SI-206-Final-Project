# work on OMDb API code here

import requests
import sqlite3
import os
import time
# Set API keys
OMDB_API_KEY = '845af1f7'
TMDB_API_KEY = 'e4d04998880c3bf739e025355c5327b9'

# API URLs
OMDB_URL = 'https://www.omdbapi.com/'
TMDB_URL = "https://api.themoviedb.org/3"

# SQLite DB setup
DB_NAME = 'movies.db'
TABLE_NAME = 'omdb_movies'

# Create SQLite database and table if it doesn't exist
def setup_database():
    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute(f'''
        CREATE TABLE IF NOT EXISTS {TABLE_NAME} (
            imdb_id TEXT PRIMARY KEY,
            title TEXT,
            imdb_rating REAL,
            rotten_tomatoes_rating TEXT
        )
    ''')
    conn.commit()
    conn.close()

# Get a page of popular movie titles from TMDb
def fetch_titles_from_tmdb(page=1):
    url = f"{TMDB_URL}/movie/popular"
    params = {
        "api_key": TMDB_API_KEY,
        "language": "en-US",
        "page": page
    }

    response = requests.get(url, params=params)
    if response.status_code != 200:
        print(f"[TMDB ERROR {response.status_code}]: {response.text}")
        return []

    try:
        data = response.json()
        return [movie['title'] for movie in data.get('results', [])]
    except Exception as e:
        print(f"[JSON DECODE ERROR]: {e}")
        print("Response text:", response.text)
        return []

# Query OMDb for details on one movie
def fetch_movie_data_from_omdb(title):
    params = {
        't': title,
        'apikey': OMDB_API_KEY
    }

    response = requests.get(OMDB_URL, params=params)
    if response.status_code != 200:
        print(f"[OMDB ERROR {response.status_code}]: {response.text}")
        return None

    try:
        data = response.json()
        if data.get("Response") == "False":
            return None

        imdb_id = data.get("imdbID")
        imdb_rating = float(data.get("imdbRating", 0)) if data.get("imdbRating") not in ['N/A', None] else None

        rt_rating = None
        for rating in data.get("Ratings", []):
            if rating["Source"] == "Rotten Tomatoes":
                rt_rating = rating["Value"]

        return {
            "title": data.get("Title"),
            "imdb_id": imdb_id,
            "imdb_rating": imdb_rating,
            "rotten_tomatoes_rating": rt_rating
        }
    except Exception as e:
        print(f"[OMDB JSON ERROR]: {e}")
        return None

# Store one movie record in SQLite (if not a duplicate)
def store_movie_in_db(movie_data):
    if not movie_data or not movie_data.get("imdb_id"):
        return

    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute(f'''
        INSERT OR IGNORE INTO {TABLE_NAME} (imdb_id, title, imdb_rating, rotten_tomatoes_rating)
        VALUES (?, ?, ?, ?)
    ''', (
        movie_data["imdb_id"],
        movie_data["title"],
        movie_data["imdb_rating"],
        movie_data["rotten_tomatoes_rating"]
    ))
    conn.commit()
    conn.close()

# Fetch and store up to 100 movies, 25 at a time
def fetch_and_store_movies():
    setup_database()

    conn = sqlite3.connect(DB_NAME)
    cursor = conn.cursor()
    cursor.execute(f"SELECT COUNT(*) FROM {TABLE_NAME}")
    current_count = cursor.fetchone()[0]
    conn.close()

    print(f"[INFO] Starting with {current_count} rows in the database.")

    page = 1
    while current_count < 100:
        titles = fetch_titles_from_tmdb(page)
        if not titles:
            break

        for title in titles:
            if current_count >= 100:
                break
            movie_data = fetch_movie_data_from_omdb(title)
            if movie_data:
                store_movie_in_db(movie_data)
                current_count += 1
                print(f"[+]{current_count}: Stored '{movie_data['title']}'")

            time.sleep(0.5)  # Avoid rate-limiting

        page += 1

    print(f"[DONE] Final count: {current_count} movies in the database.")

# Run the script
if __name__ == "__main__":
    fetch_and_store_movies()
