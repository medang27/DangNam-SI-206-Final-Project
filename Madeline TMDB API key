#work on TMDB code here

import requests
import sqlite3
import time

API_KEY = "e4d04998880c3bf739e025355c5327b9"
READ_ACCESS_TOKEN = "eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJlNGQwNDk5ODg4MGMzYmY3MzllMDI1MzU1YzUzMjdiOSIsIm5iZiI6MTc0NDExNjY4My44Miwic3ViIjoiNjdmNTFiY2IzMWM5ZjI3Mjk5YWQ1N2Q5Iiwic2NvcGVzIjpbImFwaV9yZWFkIl0sInZlcnNpb24iOjF9.HfBkmYpFkpZrYinP53M1oa7oLhL2yqBd5t6JZAxSAPc"  
HEADERS = {"Authorization": f"Bearer {READ_ACCESS_TOKEN}"}
BASE_URL = "https://api.themoviedb.org/3"

DB_NAME = "movies.db"

def create_db():
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()

    cur.execute('''
        CREATE TABLE IF NOT EXISTS movies (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            title TEXT,
            release_date TEXT,
            tmdb_id INTEGER UNIQUE
        )
    ''')

    cur.execute('''
        CREATE TABLE IF NOT EXISTS revenues (
            movie_id INTEGER,
            domestic_revenue INTEGER,
            worldwide_revenue INTEGER,
            FOREIGN KEY (movie_id) REFERENCES movies(id)
        )
    ''')

    conn.commit()
    conn.close()

def get_existing_tmdb_ids():
    conn = sqlite3.connect(DB_NAME)
    cur = conn.cursor()
    cur.execute("SELECT tmdb_id FROM movies")
    results = cur.fetchall()
    conn.close()
    return {row[0] for row in results}

def fetch_popular_movies(page=1):
    url = f"{BASE_URL}/movie/popular?api_key={API_KEY}&language=en-US&page={page}"
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()["results"]
    else:
        print("Error fetching popular movies:", response.text)
        return []
    
def get_movie_details(tmdb_id):
    url = f"{BASE_URL}/movie/{tmdb_id}?api_key={API_KEY}&language=en-US"
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()
    else:
        print(f"Error fetching details for movie ID {tmdb_id}")
        return {}
    
def store_movies(limit=25):
    create_db()
    existing_ids = get_existing_tmdb_ids()
    added_count = 0
    page = 1

    while added_count < limit:
        movies = fetch_popular_movies(page)
        if not movies:
            break

        for movie in movies:
            if movie["id"] in existing_ids:
                continue

            details = get_movie_details(movie["id"])
            title = details.get("title")
            release_date = details.get("release_date")
            domestic = details.get("revenue", 0)
            worldwide = details.get("revenue", 0)  # Use a different field if available

            conn = sqlite3.connect(DB_NAME)
            cur = conn.cursor()
            try:
                cur.execute("INSERT INTO movies (title, release_date, tmdb_id) VALUES (?, ?, ?)",
                            (title, release_date, movie["id"]))
                movie_id = cur.lastrowid
                cur.execute("INSERT INTO revenues (movie_id, domestic_revenue, worldwide_revenue) VALUES (?, ?, ?)",
                            (movie_id, domestic, worldwide))
                conn.commit()
                added_count += 1
                print(f"Added: {title}")
            except sqlite3.IntegrityError:
                print(f"Skipped duplicate: {title}")
            finally:
                conn.close()

            if added_count >= limit:
                break

        page += 1
        time.sleep(1)  # Respect API rate limits

if __name__ == "__main__":
    store_movies()